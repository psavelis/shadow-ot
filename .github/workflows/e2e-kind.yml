name: E2E Local K8s (kind)

on:
  workflow_dispatch:
  pull_request:
    branches: [ main ]

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install kind and kubectl
        uses: helm/kind-action@v1.7.0
        with:
          version: v0.23.0

      - name: Create kind cluster
        uses: helm/kind-action@v1.7.0
        with:
          cluster_name: shadow-e2e

      - name: Build images and load into kind
        run: |
          docker buildx build -f docker/Dockerfile.server -t shadow-ot/server:e2e --load .
          docker buildx build -f web/landing/Dockerfile -t shadow-ot/web:e2e --load web/landing
          docker buildx build -f web/admin/Dockerfile -t shadow-ot/admin:e2e --load web/admin
          kind load docker-image shadow-ot/server:e2e --name shadow-e2e
          kind load docker-image shadow-ot/web:e2e --name shadow-e2e
          kind load docker-image shadow-ot/admin:e2e --name shadow-e2e

      - name: Install MetalLB
        run: |
          kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.10/config/manifests/metallb-native.yaml
          cat <<EOF | kubectl apply -f -
          apiVersion: metallb.io/v1beta1
          kind: IPAddressPool
          metadata:
            name: kind-pool
            namespace: metallb-system
          spec:
            addresses:
              - 172.18.0.240-172.18.0.250
          ---
          apiVersion: metallb.io/v1beta1
          kind: L2Advertisement
          metadata:
            name: kind-advert
            namespace: metallb-system
          spec: {}
          EOF

      - name: Apply secrets
        run: |
          kubectl apply -f k8s/base/secrets-example.yaml

      - name: Deploy base and dev overlay
        run: |
          kubectl apply -k k8s/base
          kubectl apply -k k8s/overlays/dev

      - name: Switch deployments to locally built images
        run: |
          kubectl set image deploy/shadow-server shadow-server=shadow-ot/server:e2e -n shadow-ot
          kubectl set image deploy/shadow-web shadow-web=shadow-ot/web:e2e -n shadow-ot
          kubectl set image deploy/shadow-admin shadow-admin=shadow-ot/admin:e2e -n shadow-ot

      - name: Wait for services
        run: |
          kubectl wait --for=condition=available deploy/shadow-server -n shadow-ot --timeout=300s
          kubectl wait --for=condition=available deploy/shadow-web -n shadow-ot --timeout=300s
          kubectl wait --for=condition=available deploy/shadow-admin -n shadow-ot --timeout=300s
          kubectl wait --for=condition=available deploy/shadow-download -n shadow-ot --timeout=300s

      - name: Show external IPs
        run: |
          kubectl get svc -n shadow-ot -o wide

      - name: Assert external IPs present
        run: |
          for svc in shadow-web-external shadow-admin-external shadow-server-external shadow-download; do
            ip=$(kubectl get svc $svc -n shadow-ot -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            echo "$svc -> $ip"
            if [ -z "$ip" ]; then echo "Missing external IP for $svc" && exit 1; fi
          done

      - name: Smoke test web
        run: |
          EXTERNAL=$(kubectl get svc shadow-web-external -n shadow-ot -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "WEB_IP=$EXTERNAL"
          curl -fsS --max-time 10 http://$EXTERNAL || exit 1

      - name: Smoke test downloads
        run: |
          DL_IP=$(kubectl get svc shadow-download -n shadow-ot -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "DL_IP=$DL_IP"
          curl -fsS --max-time 10 http://$DL_IP/ || exit 1

      - name: Smoke test API
        run: |
          API_IP=$(kubectl get svc shadow-server -n shadow-ot -o jsonpath='{.spec.clusterIP}')
          echo "API_CLUSTER_IP=$API_IP"
          kubectl run tmp --rm -it --image=curlimages/curl -n shadow-ot --restart=Never -- curl -fsS http://$API_IP:8080/health

      - name: Check game ports reachable
        run: |
          SRV_IP=$(kubectl get svc shadow-server -n shadow-ot -o jsonpath='{.spec.clusterIP}')
          echo "SERVER_CLUSTER_IP=$SRV_IP"
          kubectl run nctmp --rm -it --image=busybox -n shadow-ot --restart=Never -- sh -c "nc -z -v $SRV_IP 7171 && nc -z -v $SRV_IP 7172"
